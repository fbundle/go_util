package vec

import (
	"math/bits"
	"sync"
	"sync/atomic"
)

func Map[T1 any, T2 any](v Vec[T1], f func(i int, x T1) (y T2)) Vec[T2] {
	w := Make[T2](v.Len())
	wg := sync.WaitGroup{}
	for i := 0; i < v.Len(); i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			w.Data[i] = f(i, v.Data[i])
		}(i)
	}
	wg.Wait()
	return w
}

func Filter[T any](v Vec[T], f func(i int, x T) bool) Vec[T] {
	w := Make[T](v.Len())
	n := atomic.Uint64{}
	wg := sync.WaitGroup{}
	for i := 0; i < v.Len(); i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			if f(i, v.Data[i]) {
				nn := n.Add(1) - 1
				w.Data[nn] = v.Data[i]
			}
		}(i)
	}
	wg.Wait()
	return w.Slice(0, int(n.Load()))
}

// nextPowerOfTwo : return the smallest power of 2 greater than x (code generated by chatgpt)
func nextPowerOfTwo(x uint64) uint64 {
	if x == 0 {
		return 1
	}
	if x > 1<<63 {
		panic("next power of 2 overflows uint64")
	}
	return 1 << (64 - bits.LeadingZeros64(x-1))
}
func Reduce[T any](w Vec[T], f func(i int, j int, x T, y T) T) T {
	v := w.Clone()
	v = v.Slice(0, int(nextPowerOfTwo(uint64(v.Len()))))

	for v.Len() > 1 {
		wg := sync.WaitGroup{}
		for i := 0; i < v.Len()/2; i++ {
			j := v.Len()/2 + i
			wg.Add(1)
			go func(i int, j int) {
				defer wg.Done()
				v.Data[i] = f(i, j, v.Data[i], v.Data[j])
			}(i, j)
		}
		wg.Wait()
		v = v.Slice(0, v.Len()/2)
	}
	return v.Data[0]
}
