package vec

import (
	"math/bits"
	"sync"
)

func Map[T1 any, T2 any](v Iter[T1], f func(i int, x T1) (y T2)) Iter[T2] {
	outCh := make(chan T2, 1)
	go func(outCh chan T2) {
		wg := sync.WaitGroup{}
		for i := 0; ; i++ {
			value, remain := v.Next()
			if !remain {
				break
			}
			wg.Add(1)
			go func() {
				defer wg.Done()
				outCh <- f(i, value)
			}()
		}
		wg.Wait()
		close(outCh)
	}(outCh)
	return MakeChanIter[T2](outCh)
}

func Filter[T any](v Iter[T], f func(i int, x T) bool) Iter[T] {
	outCh := make(chan T, 1)
	go func(outCh chan T) {
		wg := sync.WaitGroup{}
		for i := 0; ; i++ {
			value, remain := v.Next()
			if !remain {
				break
			}
			wg.Add(1)
			go func() {
				defer wg.Done()
				if f(i, value) {
					outCh <- value
				}
			}()
		}
		wg.Wait()
		close(outCh)
	}(outCh)
	return MakeChanIter[T](outCh)
}

// nextPowerOfTwo : return the smallest power of 2 greater than x (code generated by chatgpt)
func nextPowerOfTwo(x uint64) uint64 {
	if x == 0 {
		return 1
	}
	if x > 1<<63 {
		panic("next power of 2 overflows uint64")
	}
	return 1 << (64 - bits.LeadingZeros64(x-1))
}
func Reduce[T any](w Vec[T], f func(i int, j int, x T, y T) T) T {
	v := w.Clone()
	v = v.Slice(0, int(nextPowerOfTwo(uint64(v.Len()))))

	for v.Len() > 1 {
		wg := sync.WaitGroup{}
		for i := 0; i < v.Len()/2; i++ {
			j := v.Len()/2 + i
			wg.Add(1)
			go func(i int, j int) {
				defer wg.Done()
				v.Data[i] = f(i, j, v.Data[i], v.Data[j])
			}(i, j)
		}
		wg.Wait()
		v = v.Slice(0, v.Len()/2)
	}
	return v.Data[0]
}
