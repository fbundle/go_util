package uint_ntt

import (
	"math/bits"
)

// CooleyTukeyFFT :Cooley-Tukey algorithm
func CooleyTukeyFFT(x Block, omega uint64) Block {
	n := x.len()
	if n == 1 {
		return x
	}
	if n <= 0 || n%2 != 0 {
		panic("n must be power of 2")
	}
	// even and odd values of x
	e, o := makeBlock(n/2), makeBlock(n/2)
	for i := 0; i < n/2; i++ {
		e = e.set(i, x.get(2*i))
		o = o.set(i, x.get(2*i+1))
	}
	omega_2 := mul(omega, omega)
	eFFT := CooleyTukeyFFT(e, omega_2)
	oFFT := CooleyTukeyFFT(o, omega_2)

	y := makeBlock(n)
	var omega_n uint64 = 1 // omega^0
	for i := 0; i < n/2; i++ {
		t := mul(omega_n, oFFT.get(i))
		y = y.set(i, add(eFFT.get(i), t))
		y.set(i+n/2, sub(eFFT.get(i), t))
		omega_n = mul(omega_n, omega)
	}
	return y
}

// nextPowerOfTwo : return the smallest power of 2 greater than x (code generated by chatgpt)
func nextPowerOfTwo(x uint64) uint64 {
	if x == 0 {
		return 1
	}
	if x > 1<<63 {
		panic("next power of 2 overflows uint64")
	}
	return 1 << (64 - bits.LeadingZeros64(x-1))
}

func time2freq(time Block, length uint64) Block {
	// extend  into powers of 2
	l := nextPowerOfTwo(length)
	for time.len() < int(l) {
		time = time.append(0)
	}

	ω := getPrimitiveRoot(l)
	freq := trimZeros(CooleyTukeyFFT(time, ω))
	return freq
}

func freq2time(freq Block, length uint64) Block {
	// extend  into powers of 2
	l := nextPowerOfTwo(length)
	for freq.len() < int(l) {
		freq = freq.append(0)
	}

	ω := getPrimitiveRoot(l)
	il := inv(l)

	time := CooleyTukeyFFT(freq, inv(ω))
	for i := 0; i < time.len(); i++ {
		f := time.get(i)
		time = time.set(i, mul(f, il))
	}

	time = trimZeros(time)
	return time
}
