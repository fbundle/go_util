package uint_ntt

import (
	"ca/pkg/vec"
	"fmt"
	"math/bits"
)

// CooleyTukeyFFT :Cooley-Tukey algorithm
func CooleyTukeyFFT(x vec.Vec[uint64], omega uint64) vec.Vec[uint64] {
	n := x.Len()
	if n == 1 {
		return x
	}
	if n <= 0 || n%2 != 0 {
		panic("n must be power of 2")
	}
	// even and odd values of x
	e, o := vec.Make[uint64](n/2), vec.Make[uint64](n/2)
	for i := 0; i < n/2; i++ {
		e = e.Set(i, x.Get(2*i))
		o = o.Set(i, x.Get(2*i+1))
	}
	omega_2 := mul(omega, omega)
	eFFT := CooleyTukeyFFT(e, omega_2)
	oFFT := CooleyTukeyFFT(o, omega_2)

	y := vec.Make[uint64](n)
	for i := 0; i < n/2; i++ {
		j := i + n/2
		t := mul(pow(omega, uint64(i)), oFFT.Get(i))
		y = y.Set(i, add(eFFT.Get(i), t))
		y = y.Set(j, sub(eFFT.Get(i), t))
	}
	return y
}

func FFT(x vec.Vec[uint64], omega uint64) vec.Vec[uint64] {
	n := x.Len()
	z := CooleyTukeyFFT(x, omega)
	y := vec.Make[uint64](n)
	f := CooleyTukeyFFTFunctional(x.Get, n, omega)
	for i := 0; i < n; i++ {
		y = y.Set(i, f(i))
	}
	fmt.Println(z)
	fmt.Println(y)
	return y
}

func CooleyTukeyFFTFunctional(x func(int) uint64, n int, omega uint64) func(int) uint64 {
	if n == 1 {
		return x
	}
	if n <= 0 || n%2 != 0 {
		panic("n must be power of 2")
	}
	e := func(i int) uint64 {
		return x(2 * i)
	}
	o := func(i int) uint64 {
		return x(2*i + 1)
	}
	omega_2 := mul(omega, omega)
	eFFT := CooleyTukeyFFTFunctional(e, n/2, omega_2)
	oFFT := CooleyTukeyFFTFunctional(o, n/2, omega_2)
	return func(j int) uint64 {
		i := j / (n / 2)
		omega_pow := pow(omega, uint64(i))
		t := mul(omega_pow, oFFT(i))
		if j < int(n/2) {
			return add(eFFT(i), t)
		} else {
			return sub(eFFT(i), t)
		}
	}
}

// nextPowerOfTwo : return the smallest power of 2 greater than x (code generated by chatgpt)
func nextPowerOfTwo(x uint64) uint64 {
	if x == 0 {
		return 1
	}
	if x > 1<<63 {
		panic("next power of 2 overflows uint64")
	}
	return 1 << (64 - bits.LeadingZeros64(x-1))
}

func time2freq(time vec.Vec[uint64], length uint64) vec.Vec[uint64] {
	// extend  into powers of 2
	n := nextPowerOfTwo(length)
	time = time.Slice(0, int(n)) // extend to length n

	omega := getPrimitiveRoot(n)
	freq := trimZeros(CooleyTukeyFFT(time, omega))
	return freq
}

func freq2time(freq vec.Vec[uint64], length uint64) vec.Vec[uint64] {
	// extend  into powers of 2
	n := nextPowerOfTwo(length)
	freq = freq.Slice(0, int(n)) // extend to length n
	omega := getPrimitiveRoot(n)
	il := inv(n)

	time := CooleyTukeyFFT(freq, inv(omega))
	for i := 0; i < time.Len(); i++ {
		f := time.Get(i)
		time = time.Set(i, mul(f, il))
	}

	time = trimZeros(time)
	return time
}
